0
00:00:12,810 --> 00:00:15,150
各位PingCAP University学员你们好

1
00:00:15,151 --> 00:00:20,580
本课程是TiDB使用管理手册的实操部分

2
00:00:24,780 --> 00:00:25,920
在本课中

3
00:00:25,921 --> 00:00:29,160
我们首先会使用Navicat来连接一下TiDB

4
00:00:32,700 --> 00:00:36,390
在我们的测试IP服务器上

5
00:00:36,391 --> 00:00:39,150
172.16.4.232上

6
00:00:39,151 --> 00:00:40,350
我们建立了一个

7
00:00:41,880 --> 00:00:42,540
TiDB

8
00:00:42,541 --> 00:00:43,920
那么，我们首先使用

9
00:00:45,000 --> 00:00:46,950
Navicat来连接一下这个TiDB

10
00:00:57,840 --> 00:00:58,620
我们看一下

11
00:01:00,690 --> 00:01:05,550
我们这边有一个172.16.4.236的链接

12
00:01:06,960 --> 00:01:08,670
配置了4003端口

13
00:01:08,671 --> 00:01:11,280
因为这边改了端口和空密码

14
00:01:11,281 --> 00:01:12,210
TiDB在

15
00:01:13,230 --> 00:01:18,510
新建好空集群的时候，会默认生成一个密码为空的root账号

16
00:01:18,511 --> 00:01:20,370
在前面的理论课上已经讲过

17
00:01:25,410 --> 00:01:27,270
我们使用这个连接到了TiDB上面

18
00:01:27,271 --> 00:01:27,630
..

19
00:01:28,830 --> 00:01:29,940
那我们执行一条Query

20
00:01:40,140 --> 00:01:43,380
我们看到这是3.0.1的TiDB集群

21
00:01:45,360 --> 00:01:45,600
那么

22
00:01:45,601 --> 00:01:51,660
接下来我们后面操作都会使用MySQL Client来进行对TiDB操作

23
00:01:51,661 --> 00:01:54,060
那么相同的,我们使用MySQL Client
24
00:01:54,061 --> 00:01:55,290
来连接这个TiDB

25
00:02:02,460 --> 00:02:05,670
这里我们用空密码的root帐号连接到TiDB

26
00:02:08,970 --> 00:02:09,570
执行相同

27
00:02:09,571 --> 00:02:10,860
然后执行相同的操作

28
00:02:18,090 --> 00:02:19,770
我们看到这也是这个集群

29
00:02:19,771 --> 00:02:21,750
3.0.1的集群

30
00:02:21,751 --> 00:02:23,670
然后我们现在开始后面的步骤

31
00:02:25,320 --> 00:02:25,800
第一步

32
00:02:25,801 --> 00:02:28,290
我们会来进行添加用户的操作

33
00:02:29,340 --> 00:02:30,150
TiDB中

34
00:02:30,151 --> 00:02:32,070
添加用户和MySQL的行为一致

35
00:02:33,420 --> 00:02:36,480
是使用Create User命令来进行用户添加

36
00:02:37,800 --> 00:02:38,100
..

37
00:02:38,101 --> 00:02:42,180
我们来加一个myadmin的密码是123456

38
00:02:42,181 --> 00:02:42,840
..

39
00:02:44,580 --> 00:02:46,950
以前给这个用户赋上所有的权限

40
00:02:49,950 --> 00:02:50,790
OK

41
00:02:50,791 --> 00:02:52,080
我们退出客户端

42
00:02:56,010 --> 00:02:58,410
使用myadmin登录TiDB

43
00:03:01,290 --> 00:03:02,790
我们可以看到,现在就是

44
00:03:06,720 --> 00:03:11,010
myadmin这个用户，在进行TiDB的操作和连接

45
00:03:15,180 --> 00:03:19,890
相同的，我们在创建一个myuser的用户

46
00:03:19,891 --> 00:03:20,820
这个用户有

47
00:03:21,990 --> 00:03:23,700
增删改查四个权限

48
00:03:25,770 --> 00:03:27,540
我们同样使用root账号登陆

49
00:03:39,900 --> 00:03:41,100
然后新建了个账号

50
00:03:43,740 --> 00:03:46,800
给这个账号赋上增删改查的权限

51
00:03:48,180 --> 00:03:52,290
同样，使用这个账号来登录TiDB

52
00:03:58,140 --> 00:04:00,150
show grants看一下

53
00:04:00,151 --> 00:04:04,320
可以发现这个账号只有增删改查四个权限

54
00:04:06,570 --> 00:04:08,790
好,我们现在来删掉删除这个用户

55
00:04:10,290 --> 00:04:12,810
同样的使用root帐号登录到TiDB

56
00:04:14,010 --> 00:04:14,820
执行删除命令

57
00:04:18,030 --> 00:04:18,840
这个用户已经删掉

58
00:04:20,400 --> 00:04:21,120
我们可以在

59
00:04:23,430 --> 00:04:26,640
user中看到对应的账号信息

60
00:04:36,720 --> 00:04:38,670
现在只剩myadmin和root账号

61
00:04:38,671 --> 00:04:42,090
下面我们来执行修改密码

62
00:04:42,091 --> 00:04:44,610
我们希望把myadmin的密码改成654321

63
00:04:44,611 --> 00:04:45,390
...

64
00:04:46,260 --> 00:04:48,660
这时候执行mysql的密码修改命令

65
00:04:50,040 --> 00:04:50,310
同样

66
00:04:51,570 --> 00:04:55,950
我们尝试使用123456来登录这个服务器

67
00:04:55,951 --> 00:04:56,910
发现密码已经错了

68
00:04:58,950 --> 00:04:59,610
这时候我们把密码改成654321

69
00:05:01,800 --> 00:05:01,950
...

70
00:05:03,330 --> 00:05:05,190
OK，登陆到这个TiDB中了

71
00:05:05,191 --> 00:05:05,580
...

72
00:05:07,020 --> 00:05:10,140
这边就是密码相关的一些演示

73
00:05:13,980 --> 00:05:16,590
下面，来介绍表与系统视图

74
00:05:18,150 --> 00:05:19,260
首先我们来介绍

75
00:05:20,610 --> 00:05:21,090
系统表

76
00:05:23,670 --> 00:05:25,350
为了和MySQL做兼容

77
00:05:25,351 --> 00:05:28,500
我们在mysql数据库中放了TiDB

78
00:05:28,501 --> 00:05:30,090
和一些MySQL的兼容性系统表

79
00:05:31,080 --> 00:05:32,790
我进入到MySQL数据库

80
00:05:35,370 --> 00:05:37,590
用show tables看一下,OK

81
00:05:37,591 --> 00:05:41,010
我们这边可以看到有很多系统表

82
00:05:41,011 --> 00:05:44,820
这些系统表在理论课程上都已经介绍过，不做展开的介绍

83
00:05:44,821 --> 00:05:46,200
我们就进行实操环节

84
00:05:48,030 --> 00:05:48,300
首先

85
00:05:48,301 --> 00:05:49,560
我们看一下权限系统表

86
00:05:50,670 --> 00:05:51,420
权限系统是

87
00:05:53,550 --> 00:05:55,140
用来记录账号和账号相对于权限

88
00:05:55,141 --> 00:05:56,490
...

89
00:05:56,491 --> 00:05:57,900
我们可以用美化输出看一下

90
00:05:59,760 --> 00:06:01,470
root账号拥有所有的权限

91
00:06:03,600 --> 00:06:06,660
myadmin账号有一些，部分权限没有

92
00:06:11,760 --> 00:06:13,770
然后，再看一下全局的系统变量表

93
00:06:20,940 --> 00:06:22,620
我们看到非常多的系统参数

94
00:06:24,000 --> 00:06:25,080
同样,我们使用美化输出

95
00:06:26,610 --> 00:06:27,660
可以看的更加清晰一些

96
00:06:29,790 --> 00:06:31,590
同样在之前介绍过

97
00:06:31,591 --> 00:06:37,410
这边innodb_开头的，其实是TiDB为MySQL做兼容而放到里面的一些参数

98
00:06:37,411 --> 00:06:39,870
那么，这边我们需要查看TiDB相关参数的话

99
00:06:39,871 --> 00:06:41,550
其实只要选Where条件就可以

100
00:06:53,310 --> 00:06:56,670
OK，我们可以看到有34个TiDB相关的参数

101
00:06:59,100 --> 00:07:01,560
这些row的参数都是可以在线修改和调整

102
00:07:07,770 --> 00:07:08,850
下面我们来查看进程

103
00:07:12,150 --> 00:07:13,740
我们已经看到，现在有两个链接

104
00:07:13,741 --> 00:07:14,850
连接到这个TiDB

105
00:07:17,070 --> 00:07:19,410
一个是我本地的进程

106
00:07:19,411 --> 00:07:21,090
一个是我刚刚Navicat的进程

107
00:07:25,830 --> 00:07:27,450
然后再来看一下Show ddl jobs

108
00:07:29,130 --> 00:07:30,600
这是admin命令的一部分

109
00:07:32,280 --> 00:07:35,880
我们可以看到这边有一些，最近的十个

110
00:07:35,881 --> 00:07:37,560
ddl jobs的一些记录

111
00:07:40,860 --> 00:07:42,390
state是synced

112
00:07:42,391 --> 00:07:45,030
就代表这个ddl已经完成

113
00:07:45,031 --> 00:07:47,640
这边是我前面测试时用的一些ddl的记录

114
00:07:50,340 --> 00:07:52,350
我们再来用admin来查看下慢查询

115
00:07:53,820 --> 00:07:56,070
我们先直接看一下现在的慢查询有哪些

116
00:08:01,290 --> 00:08:02,970
我看到有个select sleep(2)

117
00:08:02,971 --> 00:08:05,160
这是我之前测试时候

118
00:08:06,150 --> 00:08:07,020
执行的慢查询

119
00:08:07,021 --> 00:08:09,390
我们现在来进行一个select sleep(3);

120
00:08:19,770 --> 00:08:20,760
我们可以看到

121
00:08:20,761 --> 00:08:26,460
现在整个的慢查询top 1就变成了这个select sleep(3);

122
00:08:29,280 --> 00:08:30,060
现在top2，他们有具体的执行时间

123
00:08:30,061 --> 00:08:30,420
...

124
00:08:30,421 --> 00:08:31,140
一个是9点

125
00:08:31,141 --> 00:08:31,980
一个是10点

126
00:08:37,620 --> 00:08:41,760
下面进入DDL和DML的演示(没听清)环节

127
00:08:41,761 --> 00:08:44,940
首先我们来进行，新建数据库的操作

128
00:08:44,941 --> 00:08:46,830
这边我们新建两个数据

129
00:08:46,831 --> 00:08:48,060
一个是mytest0

130
00:08:48,061 --> 00:08:49,110
一个是mytest1

131
00:08:50,340 --> 00:08:51,240
新建mytest0

132
00:08:53,910 --> 00:08:54,540
同时新建mytest1

133
00:08:54,541 --> 00:08:55,200
..

134
00:08:59,460 --> 00:09:01,080
这边mytest1已经新建

135
00:09:01,081 --> 00:09:05,250
所以我们直接输入show database这个命令

136
00:09:05,251 --> 00:09:06,150
查看一下现在数据库情况

137
00:09:12,690 --> 00:09:15,780
可以看到我们的mytest0数据库和mytest1数据库

138
00:09:19,650 --> 00:09:21,840
下面我们把mytest0数据库删除

139
00:09:37,560 --> 00:09:39,870
可以看到，我们现在已经只有mytest1数据库

140
00:09:41,670 --> 00:09:44,490
好，我们现在在mytest1数据库上进行操作

141
00:09:45,570 --> 00:09:48,840
首先进入到mytest1数据库,查看数据表

142
00:09:48,841 --> 00:09:50,160
现在这是一个空的数据库

143
00:09:51,600 --> 00:09:53,970
然后我们会建一个t1的表

144
00:09:55,320 --> 00:09:56,820
这是一个两个字段的表

145
00:09:56,821 --> 00:09:57,540
一个ID

146
00:09:57,541 --> 00:09:58,890
他是主键

147
00:09:58,891 --> 00:10:01,920
一个name,它是一个varchar的字符串的字段

148
00:10:05,790 --> 00:10:06,330
建立完之后

149
00:10:06,331 --> 00:10:08,250
我们看一下当前的数据表的情况

150
00:10:09,420 --> 00:10:11,850
这个数据库里面已有张t1的数据表

151
00:10:12,900 --> 00:10:14,550
我们向这张表中插入三条数据

152
00:10:21,060 --> 00:10:24,840
好的，我们这边使用了标准的Insert的语句来写入数据

153
00:10:24,841 --> 00:10:27,840
Insert into t1指定字段名称，values指定字段值的方式

154
00:10:27,841 --> 00:10:31,500
来写入了具体的数据

155
00:10:33,240 --> 00:10:34,770
看一下有多少数据在里面

156
00:10:38,160 --> 00:10:42,990
基本就是我们之前写入的三行数据，1 tom1,2 tom2,3 tom3

157
00:10:45,270 --> 00:10:46,560
我们先来执行更新

158
00:10:50,190 --> 00:10:53,040
update t1 set name = 'tom111' where id = 1;

159
00:10:53,041 --> 00:10:56,100
这个一个标准的更新语句

160
00:10:57,420 --> 00:10:59,010
我们执行完之后看下效果

161
00:11:02,580 --> 00:11:05,430
我们可以看到这张表中id=1的记录

162
00:11:06,930 --> 00:11:09,030
它的name字段已经变成tom111

163
00:11:09,031 --> 00:11:09,900
...

164
00:11:11,400 --> 00:11:13,650
是符合我们的预期需求

165
00:11:15,900 --> 00:11:18,090
同样，我们来进行一个删除操作

166
00:11:24,000 --> 00:11:24,750
delete from t1 where id = 3;

167
00:11:24,751 --> 00:11:29,580
这边会将我们表中id=3的这条数据删除

168
00:11:30,750 --> 00:11:33,600
我们来看一下结果记录

169
00:11:40,740 --> 00:11:43,200
我们可以看到现在只剩两条数据

170
00:11:43,201 --> 00:11:45,810
一个是id=1,一个是id=2

171
00:11:45,811 --> 00:11:46,440
符合预期

172
00:11:48,090 --> 00:11:50,070
然后我们来看一下replace操作

173
00:11:54,240 --> 00:11:55,080
replace操作

174
00:11:55,081 --> 00:11:56,880
在他碰到unique key

175
00:11:56,881 --> 00:11:58,860
包括主键等等的情况下

176
00:11:58,861 --> 00:12:00,870
他会更新这条数据

177
00:12:00,871 --> 00:12:01,770
那么我们这边

178
00:12:03,720 --> 00:12:05,250
在这个表中

179
00:12:05,251 --> 00:12:08,400
把这个id=2的数据改成tom222

180
00:12:12,420 --> 00:12:15,930
我们也看到，最后的结果是tom222，没问题

181
00:12:18,630 --> 00:12:20,010
然后我们来执行truncate table

182
00:12:21,120 --> 00:12:27,930
truncate table是会把表中的所有数据全部删除，这个行为是和MySQL一致的

183
00:12:28,950 --> 00:12:31,380
这个在TiDB底层同样和MySQL一样

184
00:12:31,381 --> 00:12:34,230
删表和重建表的一个操作

185
00:12:35,400 --> 00:12:35,760
因此

186
00:12:35,761 --> 00:12:36,570
速度是非常快的

187
00:12:39,150 --> 00:12:40,170
我们再来看一下这张表

188
00:12:41,700 --> 00:12:42,540
它已经没有任何数据

189
00:12:44,430 --> 00:12:45,870
最后，我们来drop table

190
00:12:56,850 --> 00:12:57,840
已经变成一个空库

191
00:13:01,680 --> 00:13:04,080
好，下面我们会进行一些dml和dcl的

192
00:13:05,820 --> 00:13:07,650
控制性的一些演示

193
00:13:09,330 --> 00:13:12,600
同样我们新建这个t1表

194
00:13:19,050 --> 00:13:20,160
我们现在有三行数据

195
00:13:21,870 --> 00:13:24,720
我们来进行回滚的隔离演示

196
00:13:25,920 --> 00:13:26,970
首先

197
00:13:26,971 --> 00:13:29,250
我们使用begin来显式的声明

198
00:13:29,251 --> 00:13:31,320
这个事务是需要显式打开的

199
00:13:32,340 --> 00:13:34,110
这个时候我们需要一个

200
00:13:35,280 --> 00:13:36,420
(4,'tom4')的数据

201
00:13:39,450 --> 00:13:41,100
但是这个数据并没有提交

202
00:13:42,330 --> 00:13:42,990
我们可以看到

203
00:13:44,070 --> 00:13:46,950
在这个session的隔离级别当中已经存在这行数据

204
00:13:46,951 --> 00:13:50,370
这个时候我们打开另外一个客户端

205
00:14:10,800 --> 00:14:12,660
我们来查看t1张表

206
00:14:12,661 --> 00:14:14,550
这是在另外一个session中

207
00:14:14,551 --> 00:14:16,350
如果通过隔离级别的理解是

208
00:14:16,351 --> 00:14:18,600
这时候我们应该是看不到这(4,'tom4')数据

209
00:14:19,440 --> 00:14:20,190
OK,没有错

210
00:14:20,191 --> 00:14:24,240
因为这个是显式声明的一个事务

211
00:14:24,241 --> 00:14:27,060
他并没有提交，这个时候我们进行rollback

212
00:14:29,940 --> 00:14:31,890
来查看t1表的数据

213
00:14:31,891 --> 00:14:33,690
它就是1,2,3

214
00:14:33,691 --> 00:14:35,220
然后我们再另外一个session中看一下

215
00:14:36,570 --> 00:14:38,520
tom,1,2,3没问题

216
00:14:38,521 --> 00:14:41,340
然后我们再进一个提交的，隔离级别的演示

217
00:14:46,080 --> 00:14:48,690
我们需要在session当中显式的声明

218
00:14:48,691 --> 00:14:50,190
这个事务开始

219
00:14:51,300 --> 00:14:51,600
..

220
00:14:54,660 --> 00:14:55,230
insert

221
00:14:57,990 --> 00:15:00,330
然后这个时候还没有提交

222
00:15:00,331 --> 00:15:01,440
让我们来查看一下

223
00:15:01,441 --> 00:15:02,820
4条数据

224
00:15:07,470 --> 00:15:11,370
这个时候我们可以看一下这个表的数据

225
00:15:15,480 --> 00:15:15,840
还是只有3号

226
00:15:15,841 --> 00:15:21,210
OK

227
00:15:21,211 --> 00:15:23,070
这个时候我们来commit这个事务

228
00:15:26,820 --> 00:15:27,510
这个时候

229
00:15:29,130 --> 00:15:30,720
第4号的数据已经提交成功了

230
00:15:30,721 --> 00:15:34,560
这个时候应该是整个写入了，整个的kv存储引擎当中

231
00:15:34,561 --> 00:15:35,910
这时候我们在其他的session当中

232
00:15:35,911 --> 00:15:38,940
也是能查出这个1234,没有问题

233
00:15:42,270 --> 00:15:43,290
OK,接着往下

234
00:15:45,210 --> 00:15:48,870
下面我们介绍一下TiDB支持的数据类型

235
00:15:48,871 --> 00:15:49,770
包括id，int类型

236
00:15:51,210 --> 00:15:55,320
run1 double类型，decimal类型

237
00:15:55,321 --> 00:15:58,500
varchar类型,json类型,枚举型和集合型

238
00:16:01,620 --> 00:16:03,000
我们现在先建立一张t4的表

239
00:16:07,800 --> 00:16:08,220
打完之后

240
00:16:08,221 --> 00:16:10,290
我们可以看到一下t4的整个表结构

241
00:16:16,980 --> 00:16:19,740
OK,我们所有的字段都已经匹配好

242
00:16:19,741 --> 00:16:20,190
新建成功了

243
00:16:23,190 --> 00:16:25,080
那接下来我们会介绍一下分区表

244
00:16:26,340 --> 00:16:26,760
分区表

245
00:16:26,761 --> 00:16:28,920
在MySQL上也是一个比较完整的功能

246
00:16:28,921 --> 00:16:30,690
它的整体表现与MySQL是一致的

247
00:16:31,710 --> 00:16:34,890
我们现在实现了range分区和hash分区

248
00:16:34,891 --> 00:16:37,230
首先我们会来新建一个range分区的表

249
00:16:42,210 --> 00:16:42,600
好

250
00:16:44,220 --> 00:16:46,440
那我们就开始新建一张range分区的表

251
00:16:51,570 --> 00:16:52,650
(没听清)

252
00:17:22,800 --> 00:17:27,630
这边我们可以看到是需要上面的字段

253
00:17:27,631 --> 00:17:29,250
声明是跟普通的表一样

254
00:17:29,251 --> 00:17:32,670
下面是PARTITION BY RANGE (TO_DAYS)

255
00:17:32,671 --> 00:17:33,660
然后这个方式

256
00:17:33,661 --> 00:17:43,530
我们这边是把.带着这个hiredate字段使用TO_DAYS来精准到每一天来进行一个按天的分区的一个情况

257
00:17:45,840 --> 00:17:47,340
OK，我们可以看一下这张表的表结构

258
00:17:58,290 --> 00:17:58,530
..

259
00:17:58,531 --> 00:18:00,690
是这么一个情况

260
00:18:00,691 --> 00:18:04,470
这边TO_DAYS函数转化成了具体的时间日期

261
00:18:14,940 --> 00:18:16,530
下面我们建立一个hash分区的表

262
00:18:22,080 --> 00:18:25,980
相同的，上面的部分是跟普通建表一样

263
00:18:25,981 --> 00:18:27,390
这个时候我们用PARTITION BY HASH(id)

264
00:18:27,391 --> 00:18:29,310
来分成了四个分区

265
00:18:29,311 --> 00:18:30,000
...

266
00:18:39,120 --> 00:18:40,830
我们可以看到，这张表已经新建完成

267
00:18:45,570 --> 00:18:45,810
下面

268
00:18:45,811 --> 00:18:47,760
我们会查看一下统计信息

269
00:18:48,990 --> 00:18:50,100
关于统计信息的命令

270
00:18:50,101 --> 00:18:52,260
分为查看和分析命令

271
00:18:52,261 --> 00:18:55,890
首先我们看查看的统计信息的一些系统级的参数

272
00:18:58,650 --> 00:19:00,240
这边我们前面已经介绍过

273
00:19:00,241 --> 00:19:03,210
这边是统计信息相关的系统里的参数

274
00:19:03,211 --> 00:19:06,690
这边我们可以看到统计信息收集的阈值是0.5

275
00:19:06,691 --> 00:19:09,480
就是当表内有50%数据变更之后

276
00:19:09,481 --> 00:19:12,090
统计进行会进行重新收集

277
00:19:12,091 --> 00:19:14,490
同时统计信息是全天候待命

278
00:19:14,491 --> 00:19:16,290
如果我们要避开业务高峰期

279
00:19:16,291 --> 00:19:17,790
我们可以修改这边相应的值

280
00:19:20,580 --> 00:19:21,900
今天有一个新引入的参数

281
00:19:21,901 --> 00:19:23,310
这是我们一个未来的

282
00:19:23,311 --> 00:19:25,260
会默认打开了一个快速收集统计的参数

283
00:19:25,261 --> 00:19:28,950
就是默认调度抽烟的一个方式来收集统计信息

284
00:19:28,951 --> 00:19:29,580
...

285
00:19:30,930 --> 00:19:31,860
我们来看一下

286
00:19:33,120 --> 00:19:36,000
当前我们数据库中表的一些统计信息

287
00:19:38,220 --> 00:19:39,330
我们可以看到

288
00:19:39,331 --> 00:19:42,180
这边我们建的t1表,t4表

289
00:19:42,181 --> 00:19:44,310
和my_range_datetime表,my_member表

290
00:19:45,660 --> 00:19:46,950
这边的分区表

291
00:19:46,951 --> 00:19:49,440
在我们TiDB的底层

292
00:19:49,441 --> 00:19:52,080
其实是一个一个具体的数据表

293
00:19:52,081 --> 00:19:55,590
所以说他这边有一些partition name来分的区

294
00:19:55,591 --> 00:19:56,700
我们可以看到

295
00:19:56,701 --> 00:19:58,080
t1表目前它的healthy为0

296
00:19:58,081 --> 00:19:58,650
它没有收集过统计信息

297
00:19:58,651 --> 00:19:59,220
...

298
00:20:00,600 --> 00:20:03,780
这时候我们需要analyze table来收集统计信息

299
00:20:06,300 --> 00:20:08,130
大家看一下,这个统计信息的状态

300
00:20:08,131 --> 00:20:10,260
现在这个表的健康度是100%

301
00:20:10,261 --> 00:20:11,490
当前统计信息全部

302
00:20:11,491 --> 00:20:12,540
结束收集完毕

303
00:20:16,230 --> 00:20:17,910
下面我们再看一下索引的创建、删除

304
00:20:17,911 --> 00:20:18,750
与查看

305
00:20:20,700 --> 00:20:22,200
我们可以看一下第一张表的索引

306
00:20:22,201 --> 00:20:25,920
我们现在看到这张表只有一个主键索引

307
00:20:25,921 --> 00:20:30,630
就是我们使用标准的创建索引的语法create index

308
00:20:31,530 --> 00:20:34,290
index名称 on t1表的name字段

309
00:20:35,580 --> 00:20:38,370
这个时候我们再看一下这张表的索引的情况

310
00:20:39,750 --> 00:20:41,910
我们可以看到t1表已经有一个索引

311
00:20:43,230 --> 00:20:45,570
他已经是name字段的一个索引

312
00:20:47,340 --> 00:20:48,330
是一个B树类型的

313
00:20:51,180 --> 00:20:53,400
那么我们再来看一下删除索引

314
00:20:55,350 --> 00:20:56,100
...

315
00:21:09,330 --> 00:21:10,770
删除语法,这边我们使用

316
00:21:14,310 --> 00:21:16,320
drop index来进行一个索引删除

317
00:21:16,321 --> 00:21:16,920
...

318
00:21:23,610 --> 00:21:26,160
OK,我们再来查看一下这张表的一些索引

319
00:21:26,161 --> 00:21:26,550
...

320
00:21:28,560 --> 00:21:32,370
好我们现在可以看到这张表的这个index

321
00:21:32,371 --> 00:21:33,330
name这个名字的索引已经被删掉了

322
00:21:40,050 --> 00:21:42,300
好的，今天的TiDB使用管理手册

323
00:21:42,301 --> 00:21:44,730
相关的实操部分已经完成

324
00:21:44,731 --> 00:21:45,180
感谢各位
